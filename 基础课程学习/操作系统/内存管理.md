## 硬件

我们需要确保每个进程都有一个单独的内存空间。单独的进程内存空间可以保护进程而不互相影响。为了分开内存空间，我们需要能够确定一个进程可以访问的合法地址的范围：并且确保该进程只能访问这些合法的地址。通过两个寄存器，通常为基地址和界限地址，我们可以提供这种保护。

- 基地址寄存器含有最小的合法的物理内存地址
- 界限地址寄存器指定了范围的大小

![](/static/images/2006/p009.png)

## 地址绑定

程序作为二进制的可执行文件，存放在磁盘上。为了执行，程序被调入内存，并放在进程中。根据采用的内存管理，进程在执行时可以在磁盘和内存之间移动。在磁盘上等待调到内存以便执行的进程形成了输入队列。

通常，指令和数据绑定到存储器地址可在沿途的任何一步中执行：

![](/static/images/2006/p010.png)

- 编译时：如果在编译时就已知道进程将在内存中的驻留地址，那么就可以生成绝对代码。MS-DOS的.COM格式的程序就是在编译时绑定成绝对代码的。
- 加载时：如果在编译时并不知道进程将驻留何处，那么编译器就应生成可重定位代码。对于这种情况，最后绑定会延迟到加载时才进行。
- 执行时：如果进程在执行时可以从一个内存段移动到另一个内存段，那么绑定应延迟到执行时才执行。

## 逻辑地址空间，物理地址空间

- CPU生成的地址通常称为逻辑地址
- 而内存单元看到的地址通常称为物理地址。

编译时和加载时的地址绑定方法生成相同的逻辑地址和物理地址。然而，执行时的地址绑定方案生成不同的逻辑地址和物理地址。也称逻辑地址为虚拟地址。

从虚拟地址到物理地址的运行时映射是由内存管理单元的硬件设备完成的。

## 动态加载

为了获得更好的内存空间利用率，可以使用动态加载。采用动态加载时，一个程序只有在调用时，才会加载。所有程序都以可重定位加载格式保存在磁盘上。

## 内存分配

动态存储分配问题：根据一组空闲孔来分配大小为n的请求

这个问题有许多解法：从一组可用孔中选择一个空闲孔的最为常用方法有：首次适应，最优适应，最差适应

- 首次适应：分配首个足够大的孔
- 最优适应：分配最小的足够大的孔
- 最差适应：分配最大的孔

模拟结果显示：首次适应和最优适应在执行时间和利用空间方面都好于最差适应。首次适应和最优适应在利用空间方面相当，但是首次适应要更快一些。

使用首次适应和最优适应算法都有外部碎片问题。

外部碎片问题的一种解决方式是紧缩。它的目的是移动内存内容，以便将所有空闲空间合并成一个整块。然而，如果重定位是静态的，并且在汇编时或者加载时进程的，那么就不能紧缩。只有重定位是动态的，并且在运行时进行的，才可进行紧缩。

外部碎片化问题的另一个可能的解决方案是：允许进程的逻辑地址空间是不连续的，这样，只要有物理内存可用，就允许为进程分配内存。方案是分段+分页。

## 分段

逻辑地址空间是由一组段构成。每个段都有名称和长度。地址指定了段名称和段内偏移。因此用户通过两个量来指定地址：段名称和段偏移。

为了实现简单起见，段是编号的，是通过段号而不是段名称来引用。因此，逻辑地址由有序对组成：

<段号，偏移>

通常，在编译用户程序时，编译器会根据输入程序来自动构造段，一个C编译器可能会创建如下段：代码、全局变量、堆、每个线程使用的栈、标准的C库

## 分页

分段允许进程的物理地址空间是非连续的。分页是提供这种优势的另外一种内存管理方案。

然而，分页避免了外部碎片和紧缩，而分段不可以。

实现分页的基本方法是：

- 将物理内存分为固定大小的块，称为帧或者页帧（frame）；
- 将逻辑内存也分为同样大小的块，称为页或者页面（page）

当需要执行一个进程时，它的页从文件系统或者备份存储等源处，加载到内存的可用帧。

由CPU生成的每个地址分为两部分：页码(page number)(p)和页偏移(page offset)(d)。页码作为页表的索引。页表包含每页所在物理内存的基地址。这个基地址和页偏移的组合就形成了物理内存地址，可发送到物理单元。

![](/static/images/2006/p011.png)

- 页大小和帧大小是由硬件来决定的。
- 页的大小是2的幂；
  - 根据计算机体系结构的不同，页大小从512字节到1GB不等。
  - 将页大小选为2的幂可以方便的将逻辑地址转为页码和页偏移。
- 如果逻辑地址空间为2^m, 且页大小为2^n字节，那么逻辑地址的高m-n位表示页码，而低n位表示页偏移

## 虚拟内存

优势：

- 虚拟内存技术允许执行程序不必完全处于内存中。
- 这种方案的一个优点是：程序可以大于物理内存。
- 此外，虚拟内存将内存抽象成一个巨大的、统一的存储数组，进而实现了用户看到的逻辑内存与物理内存的分离。
- 这种技术使得程序员不再担忧内存容量的限制。
- 虚拟内存还允许进程轻松共享文件和实现共享内存。
- 此外，它为创建进程提供了有效的机制。

劣势：

- 虚拟内存的实现并不容易，并且使用不当还可能会大大降低性能。

## 虚拟地址空间

进程的虚拟地址空间就是进程如何在内存中存放的逻辑视图。

![](/static/images/2006/p012.png)

随着动态内存的分配，允许堆向上生长，还允许堆栈向下生长。堆与堆栈之前的巨大空白空间为虚拟地址的一部分。只有堆和堆栈生长时，才需要实际的物理页。

## 请求调页（demand paging）

仅在需要的时候才加载页面，这种技术称为请求调页。

如果进程视图访问那些尚未调入内存中的页面时，情况会如何？对标记为无效的页面会产生缺页错误(page fault)。

处理这种缺页错误的程序很简单：

1. 检查这个进程的内部表（通常与PCB一起保存），以确定该引用是有效的还是无效的内存访问
2. 如果引用无效，那么终止进程。如果引用有效，但是尚未调入页面，那么现在就应该调入。
3. 找到一个空闲帧（例如从空闲链表上得到一个）
4. 调度一个磁盘操作，以将所需页面读到刚分配的帧
5. 当磁盘读取完成时，修改进程的内部表和页表，以指示该页面现在处于内存中
6. 重新启动被陷阱中断的指令。该进程现在能访问所需的页面，就好像它总是在内存中

## 页面置换

如果具有10页的一个进程实际上只使用了其中的一半，那么请求调页就节省了用以加载从不使用的另外5页所需的I/O。

另外通过运行两倍的进程，增加了多道程度。因此如果有40帧，那么可以运行8个进程。

如果增加了多道程度，那么可能会过度分配内存。

页面置换采用如下方法：

如果没有空闲帧，那么就查找当前不在使用的一个帧，并释放它。

为了实现请求调页，必须解决两个主要问题：应设计帧分配算法、页面置换算法。也就是说，如果有多个进程在内存中，则必须决定要给每个进程分配多少帧；并且当需要页面置换时，必须选择要置换的帧。
